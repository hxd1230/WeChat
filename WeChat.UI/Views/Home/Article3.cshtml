
@{
    Layout = null;
}

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Java8 新特性(二)- Stream</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link href="~/css/style.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" src="~/js/cufon-yui.js"></script>
    <script type="text/javascript" src="~/js/arial.js"></script>
    <script type="text/javascript" src="~/js/cuf_run.js"></script>
    <script type="text/javascript" src="~/js/jquery-1.3.2.min.js"></script>
    <script type="text/javascript" src="~/js/radius.js"></script>
    <!-- CuFon ends -->
</head>
<body>
    <div class="main">

        <div class="header">
            <div class="header_resize">
                <div class="logo"><h1><a href="index.html">HeXiaoDong.top</a></h1></div>
                <div class="menu_nav">
                    <ul>
                        <li><a href="@Url.Action("Index")">首页</a></li>
                        <li><a href="@Url.Action("Blog",new { id=1})">最新博客</a></li>
                        <li><a href="@Url.Action("Contact")">联系我</a></li>
                    </ul>
                </div>
                <div class="clr"></div>
            </div>
        </div>

        <div class="content">
            <div class="content_resize">
                <div class="mainbar">
                    <div class="article">
                        <h2><span>Java8 新特性(二)- Stream</span></h2><div class="clr"></div>
                        <p>Stream 用来处理集合数据的，通过 stream 操作可以实现 SQL 的拥有的大部分查询功能</p>
                        <blockquote>
                            <p><a href="https://docs.oracle.com/javase/8/docs/api/">Java8 API 官方文档</a></p>
                        </blockquote>
                        <p>下面借助例子，演示 stream 操作</p>
                        <p>Java userList 列表</p>
<pre class="java"><code class="hljs"><span class="hljs-keyword">private</span> List&lt;User&gt; userList = Arrays.asList(
                        <span class="hljs-keyword">new</span> User(<span class="hljs-number">101</span>, <span class="hljs-string">"小明"</span>, <span class="hljs-number">10</span>, <span class="hljs-string">"男"</span>, <span class="hljs-string">"青海省"</span>, <span class="hljs-string">"西宁市"</span>),
                        <span class="hljs-keyword">new</span> User(<span class="hljs-number">102</span>, <span class="hljs-string">"小青"</span>, <span class="hljs-number">12</span>, <span class="hljs-string">"女"</span>, <span class="hljs-string">"宁夏回族自治区"</span>, <span class="hljs-string">"银川市"</span>),
                        <span class="hljs-keyword">new</span> User(<span class="hljs-number">103</span>, <span class="hljs-string">"小海"</span>, <span class="hljs-number">8</span>, <span class="hljs-string">"男"</span>, <span class="hljs-string">"西藏自治区"</span>, <span class="hljs-string">"拉萨市"</span>),
                        <span class="hljs-keyword">new</span> User(<span class="hljs-number">108</span>, <span class="hljs-string">"阿刁"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"女"</span>, <span class="hljs-string">"西藏自治区"</span>, <span class="hljs-string">"拉萨市"</span>),
                        <span class="hljs-keyword">new</span> User(<span class="hljs-number">104</span>, <span class="hljs-string">"小阳"</span>, <span class="hljs-number">9</span>, <span class="hljs-string">"女"</span>, <span class="hljs-string">"新疆维吾尔自治区"</span>, <span class="hljs-string">"乌鲁木齐市"</span>),
                        <span class="hljs-keyword">new</span> User(<span class="hljs-number">105</span>, <span class="hljs-string">"小强"</span>, <span class="hljs-number">14</span>, <span class="hljs-string">"男"</span>, <span class="hljs-string">"陕西省"</span>, <span class="hljs-string">"西安市"</span>),
                        <span class="hljs-keyword">new</span> User(<span class="hljs-number">106</span>, <span class="hljs-string">"小帅"</span>, <span class="hljs-number">15</span>, <span class="hljs-string">"男"</span>, <span class="hljs-string">"河北省"</span>, <span class="hljs-string">"石家庄市"</span>),
                        <span class="hljs-keyword">new</span> User(<span class="hljs-number">107</span>, <span class="hljs-string">"小云"</span>, <span class="hljs-number">15</span>, <span class="hljs-string">"女"</span>, <span class="hljs-string">"河北省"</span>, <span class="hljs-string">"石家庄市"</span>)
);</code></pre>
                        <p>MySQL user 表数据</p>
<pre class="sql"><code class="hljs"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`user`</span>;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span>  (
                        <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) PRIMARY <span class="hljs-keyword">KEY</span>,
                        <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),
                        <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>),
                        <span class="hljs-string">`gender`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),
                        <span class="hljs-string">`province`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>),
                        <span class="hljs-string">`city`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>)
) ;

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`user`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">101</span>, <span class="hljs-string">'小明'</span>, <span class="hljs-number">10</span>, <span class="hljs-string">'男'</span>, <span class="hljs-string">'青海省'</span>, <span class="hljs-string">'西宁市'</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`user`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">102</span>, <span class="hljs-string">'小青'</span>, <span class="hljs-number">12</span>, <span class="hljs-string">'女'</span>, <span class="hljs-string">'宁夏回族自治区'</span>, <span class="hljs-string">'银川市'</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`user`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">103</span>, <span class="hljs-string">'小海'</span>, <span class="hljs-number">8</span>, <span class="hljs-string">'男'</span>, <span class="hljs-string">'西藏自治区'</span>, <span class="hljs-string">'拉萨市'</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`user`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">104</span>, <span class="hljs-string">'小阳'</span>, <span class="hljs-number">9</span>, <span class="hljs-string">'女'</span>, <span class="hljs-string">'新疆维吾尔自治区'</span>, <span class="hljs-string">'乌鲁木齐市'</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`user`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">105</span>, <span class="hljs-string">'小强'</span>, <span class="hljs-number">14</span>, <span class="hljs-string">'男'</span>, <span class="hljs-string">'陕西省'</span>, <span class="hljs-string">'西安市'</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`user`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">106</span>, <span class="hljs-string">'小帅'</span>, <span class="hljs-number">15</span>, <span class="hljs-string">'男'</span>, <span class="hljs-string">'河北省'</span>, <span class="hljs-string">'石家庄市'</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`user`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">107</span>, <span class="hljs-string">'小云'</span>, <span class="hljs-number">15</span>, <span class="hljs-string">'女'</span>, <span class="hljs-string">'河北省'</span>, <span class="hljs-string">'石家庄市'</span>);</code></pre>
                        <h3 id="查询字段-select---map">查询字段 select - map</h3>
<pre class="java"><code class="hljs"><span class="hljs-comment">// select id from user</span>
userList.stream()
    .map(e -&gt; e.getId())
    .forEach(System.out::println);</code></pre>
                        <p><em>至于如何实现 <code>select id, name from user</code> 查询多字段在下面 collector 收集器会详细讲解</em></p>
                        <h3 id="条件-where---filter">条件 where - filter</h3>
<pre class="java"><code class="hljs"><span class="hljs-comment">// select * from user where age&lt;10</span>
userList.stream()
        .filter(e-&gt; e.getAge() &lt; <span class="hljs-number">10</span>)
        .forEach(System.out::println);

<span class="hljs-comment">// select * from user where age&lt;10 and gender='男'</span>
userList.stream()
        .filter(e-&gt;e.getAge() &lt; <span class="hljs-number">10</span>)
        .filter(e-&gt;e.getGender()==<span class="hljs-string">"男"</span>)
        .forEach(System.out::println);</code></pre>
                        <h3 id="最值总和数量均值max-min-sum-count-average">最值、总和、数量、均值(max, min, sum, count, average)</h3>
<pre class="java"><code class="hljs"><span class="hljs-comment">// select max(age), min(age), sum(age), count(age), avg(age) from user</span>
<span class="hljs-comment">// max</span>
Optional&lt;Integer&gt; maxAge = userList.stream()
                                .map(e -&gt; e.getAge())
                                .max(Comparator.comparingInt(x -&gt; x));
<span class="hljs-comment">// 等同于</span>
<span class="hljs-comment">// Optional&lt;Integer&gt; maxAge =  userList.stream()</span>
<span class="hljs-comment">//  .map(e -&gt; e.getAge())</span>
<span class="hljs-comment">//  .max((x, y) -&gt; x-y);</span>

<span class="hljs-comment">// min</span>
Optional&lt;Integer&gt; minAge = userList.stream()
                                .map(e -&gt; e.getAge())
                                .min(Comparator.comparingInt(x -&gt; x));
<span class="hljs-comment">// sum</span>
Optional&lt;Integer&gt; sumAge = userList.stream()
                                .map(e -&gt; e.getAge())
                                .reduce((e, u) -&gt; e + u);
<span class="hljs-comment">// count</span>
<span class="hljs-keyword">long</span> count = userList.stream()
                .map(e -&gt; e.getAge())
                .count();
<span class="hljs-comment">// 平均值=总和/数量</span></code></pre>
                        <h3 id="排序-order-by---sorted">排序 order by - sorted</h3>
<pre class="java"><code class="hljs"><span class="hljs-comment">// select * from user order by age</span>
userList.stream()
        .sorted(Comparator.comparingInt(User::getAge))
        .forEach(System.out::println);</code></pre>
                        <h3 id="分页-limit---skiplimit">分页 limit - skip、limit</h3>
<pre class="java"><code class="hljs"><span class="hljs-comment">// select * from user limit 5</span>
userList.stream()
        .limit(<span class="hljs-number">5</span>)
        .forEach(System.out::println);

<span class="hljs-comment">// select * from user limit 5, 5</span>
userList.stream()
        .skip(<span class="hljs-number">5</span>)
        .limit(<span class="hljs-number">5</span>)
        .forEach(System.out::println);

<span class="hljs-comment">// select * from user order by age limit 1</span>
userList.stream()
        .sorted(Comparator.comparingInt(User::getAge))
        .limit(<span class="hljs-number">1</span>)
        .forEach(System.out::println);
<span class="hljs-comment">// 或者</span>
Optional&lt;User&gt; minAgeUser = userList.stream()
                                .sorted(Comparator.comparingInt(User::getAge))
                                .findFirst();</code></pre>
                        <h3 id="是否存在-exists---anymatch">是否存在 exists - anymatch</h3>
<pre class="java"><code class="hljs"><span class="hljs-comment">// select exists(select * from user where name='小海')</span>
<span class="hljs-comment">// 有没有名字叫“小海”的用户</span>
<span class="hljs-keyword">boolean</span> exists0 = userList.stream()
                        .anyMatch(e -&gt; e.getName().equals(<span class="hljs-string">"小海"</span>));

<span class="hljs-comment">// select not exists(select * from user where name='小海')</span>
<span class="hljs-comment">// 是不是没有名字叫“小海”的用户</span>
<span class="hljs-keyword">boolean</span> exists1 = userList.stream()
                        .noneMatch(e -&gt; e.getName().equals(<span class="hljs-string">"小海"</span>));

<span class="hljs-comment">// 是不是所有用户年龄都小于10岁</span>
<span class="hljs-keyword">boolean</span> exists2 = userList.stream()
                        .allMatch(e -&gt; e.getAge() &lt; <span class="hljs-number">10</span>);</code></pre>
                        <h3 id="收集操作-collect">收集操作 collect</h3>
                        <p>收集操作就是遍历 stream 中的元素，并进行累加处理，即归约 reduction</p>
                        <p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#Reduction">归约的定义</a>：</strong></p>
                        <blockquote>
                            <p>A <em>reduction</em> operation (also called a <em>fold</em>) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list.</p>
                        </blockquote>
                        <p>前面提到的 <code>max()</code> <code>min()</code> <code>count()</code> <code>reduce()</code> 都属于 <em>reduction</em> operation</p>
                        <p>但 <code>collect()</code> 又和前面这几种归约操作有所区别，它是 <strong>Mutable reduction 动态归约</strong></p>
                        <p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#MutableReduction">动态归约的定义</a>：</strong></p>
                        <blockquote>
                            <p>A <em>mutable reduction operation</em> accumulates input elements into a mutable result container, such as a <code>Collection</code> or <code>StringBuilder</code>, as it processes the elements in the stream</p>
                        </blockquote>
                        <p>区别：动态归约将结果放进 <code>Collection</code> <code>StringBuilder</code> 这样的动态容器中，所以称为动态归约。</p>
                        <p>Stream 接口提供了两个 collect() 方法</p>
<pre class="java"><code class="hljs">&lt;R&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Supplier&lt;R&gt; supplier,
                BiConsumer&lt;R, ? <span class="hljs-keyword">super</span> T&gt; accumulator,
                BiConsumer&lt;R, R&gt; combiner)</span></span>;

&lt;R, A&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-keyword">super</span> T, A, R&gt; collector)</span></span>;</code></pre>
                        <p>我们只需理解了第一个方法，第二个方法就手到擒来了</p>
                        <p>理解第一个 collect 方法，强烈建议阅读文档 <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#MutableReduction">动态归约的定义</a></strong>，下面只简单的介绍一下它</p>
                        <p>三个参数：</p>
                        <ul>
                            <li>供给者 supplier：负责提供动态容器，例如 Collectors、StringBuilder</li>
                            <li>累加器 accumulator：负责将流中的元素做累加处理</li>
                            <li>合并者 combiner ：负责将两个容器的元素合并在一起</li>
                        </ul>
                        <blockquote>
                            <p>
                                在串行流中，combiner 根本没有执行，所以随便写点啥满足参数对象就行。<br />
                                <em>如果说串行流是单线程，那么并行流就是多线程了</em>
                            </p>
                        </blockquote>
                        <p>举个例子：</p>
<pre class="java"><code class="hljs">
     ArrayList&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
                        <span class="hljs-keyword">for</span> (T element : stream) {
         strings.add(element.toString());
     }
                        <span class="hljs-comment">// 等同于</span>
    ArrayList&lt;String&gt; strings = stream.collect(() -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(),
                                                (c, e) -&gt; c.add(e.toString()),
                                                (c1, c2) -&gt; c1.addAll(c2));</code></pre>
                        <p>
                            与其传递三个参数这么麻烦，还不如直接传递一个对象呢！<br />
                            这就是第二个 <code>collect()</code> 方法的由来，使用收集器 Collector 来替代三个参数
                        </p>
                        <p>实际上，我们一般不需要自己创建 Collector 对象，Java8 提供了一个 Collectors 类，专门提供收集器 Collector 对象。毕竟我们平时能够使用到的收集操作也就那几种：转为集合对象、分组、统计。</p>
                        <p>下面以例子演示</p>
                        <hr />
                        <p><em>在初看 stream 操作的时候，我被什么创建、中间操作、终止操作、不会改变原对象给弄晕了，我根本不关心这些，我的第一想法是怎么将操作后的数据导出来，重新变成集合对象。</em></p>
                        <h4 id="tocollection">toCollection</h4>
                        <p>不使用收集器的情况下：</p>
<pre class="java"><code class="hljs">List&lt;User&gt; subUserList1 = userList.stream()
                .filter(e -&gt; e.getAge() &lt; <span class="hljs-number">10</span>)
                .filter(e -&gt; e.getGender() == <span class="hljs-string">"男"</span>)
                .collect(() -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(),
                        (c, e) -&gt; c.add(e),
                        (c1, c2) -&gt; c1.addAll(c2));</code></pre>
                        <p><em>在 collect() 方法第二个参数累加器 accumulator <code>(c, e) -&gt; c.add(e)</code> 这里，对流中元素进行了遍历，所以可以把流中元素添加到任意的集合容器中，List、Set、Map 等等</em></p>
                        <p>使用 Collectors 工具类提供的收集器：</p>
<pre class="java"><code class="hljs"><span class="hljs-comment">// toList()</span>
List&lt;User&gt; list = userList.stream()
                .filter(e -&gt; e.getAge() &lt; <span class="hljs-number">10</span>)
                .filter(e -&gt; e.getGender() == <span class="hljs-string">"男"</span>)
                .collect(Collectors.toList());

<span class="hljs-comment">// toSet()</span>
Set&lt;User&gt; set = userList.stream()
                .filter(e -&gt; e.getAge() &lt; <span class="hljs-number">10</span>)
                .filter(e -&gt; e.getGender() == <span class="hljs-string">"男"</span>)
                .collect(Collectors.toSet());

<span class="hljs-comment">// toCollection()，想要返回什么容器，就 new 一个</span>
ArrayList&lt;User&gt; collection = userList.stream()
                .filter(e -&gt; e.getAge() &lt; <span class="hljs-number">10</span>)
                .filter(e -&gt; e.getGender() == <span class="hljs-string">"男"</span>)
                .collect(Collectors.toCollection(
                    () -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()
                ));</code></pre>
                        <p>这里插播一条新闻：<strong>如何将流转为数组？</strong></p>
                        <p><strong><code>Stream</code></strong> 提供了方法 toArray()</p>
<pre class="java"><code class="hljs">Object[] toArray();
&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</code></pre>
                        <p>小试牛刀：</p>
<pre class="java"><code class="hljs">Object[] nameArray = userList.stream()
        .map(e -&gt; e.getName())
        .toArray();
Arrays.stream(nameArray)
        .forEach(System.out::println);
<span class="hljs-comment">// 转为 User 对象数组</span>
User[] users = userList.stream()
        .filter(e -&gt; e.getGender() == <span class="hljs-string">"女"</span>)
        .toArray(User[]::<span class="hljs-keyword">new</span>);
Arrays.stream(users)
        .forEach(System.out::println);</code></pre>
                        <h4 id="tostringbuilder">toStringBuilder</h4>
                        <p>不使用收集器的情况下：</p>
<pre class="java"><code class="hljs">StringBuilder joinName = userList.stream()
                .map(e -&gt; e.getName())
                .collect(StringBuilder::<span class="hljs-keyword">new</span>,
                        (s, e) -&gt;  s = s.length() &gt; <span class="hljs-number">0</span> ? s.append(<span class="hljs-string">"-"</span> + e) : s.append(e),
                        (s1, s2) -&gt; s1.append(s2)
                );</code></pre>
                        <p><em>谁能告诉我在Java中怎么单独使用三元运算符？<code>s = s.length() &gt; 0 ? s.append("-" + e) : s.append(e)</code> 我想把 <code>s =</code> 省略掉，但 Java 中不行</em></p>
                        <p>使用 <code>Collectors</code> 类提供的收集器：</p>
<pre class="java"><code class="hljs">String joinName1 = userList.stream()
                .map(e -&gt; e.getName())
                .collect(Collectors.joining());

String joinName2 = userList.stream()
    .map(e -&gt; e.getName())
    .collect(Collectors.joining(<span class="hljs-string">"-"</span>));

String joinName3 = userList.stream()
    .map(e -&gt; e.getName())
    .collect(Collectors.joining(<span class="hljs-string">"-"</span>, <span class="hljs-string">"["</span>, <span class="hljs-string">"]"</span>));</code></pre>
                        <p>至于 Collectors.joining() 参数分别代表什么含义，看一下它们的参数名称，就明白了</p>
<pre class="java"><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,    <span class="hljs-comment">// 分隔符</span>
                                                             CharSequence prefix,   <span class="hljs-comment">// 前缀</span>
                                                             CharSequence suffix)   <span class="hljs-comment">// 后缀</span></code></pre>
                        <h4 id="tomap">toMap</h4>
                        <p>在 Collectors 中一共有3个 <code>toMap()</code>,它们用来处理不同的问题</p>
                        <p><strong>两个参数的 toMap</strong></p>
<pre class="java"><code class="hljs"> Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; keyMapper,
                                    Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; valueMapper) {
                        <span class="hljs-keyword">return</span> toMap(keyMapper, valueMapper, throwingMerger(), HashMap::<span class="hljs-keyword">new</span>);
    }</code></pre>
                        <blockquote>
                            <p>参数 <code>keyMapper</code> 用来获取key；<code>valueMapper</code> 用来获取 value</p>
                            <p>它的内部调用了四个参数的 toMap() 方法</p>
                        </blockquote>
                        <p>例子</p>
<pre class="java"><code class="hljs">Map&lt;Integer, User&gt; map1 = userList.stream()
    .collect(Collectors.toMap(e -&gt; e.getId(), Function.identity()));
System.out.println(map1);
<span class="hljs-comment">// Function.identity() 等价于 e -&gt; e</span>

<span class="hljs-comment">// select id, name, gender from user</span>
Map&lt;Integer, Map&lt;String, Object&gt;&gt; map2 = userList.stream()
    .collect(Collectors.toMap(e -&gt; e.getId(), e -&gt; {
        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        map.put(<span class="hljs-string">"gender"</span>, e.getGender());
        map.put(<span class="hljs-string">"name"</span>, e.getName());
        map.put(<span class="hljs-string">"id"</span>, e.getId());
                        <span class="hljs-keyword">return</span> map;
    }));
System.out.println(map2);</code></pre>
                        <p>
                            你：如果 key 冲突了咋办？<br />
                            Java8：你想咋办就咋办
                        </p>
                        <p><strong>三个参数的 toMap</strong></p>
<pre class="java"><code class="hljs">Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; keyMapper,
                                    Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; valueMapper,
                                    BinaryOperator&lt;U&gt; mergeFunction) {
                        <span class="hljs-keyword">return</span> toMap(keyMapper, valueMapper, mergeFunction, HashMap::<span class="hljs-keyword">new</span>);
    }</code></pre>
                        <blockquote>
                            <p>第三个参数 <code>mergeFunction</code> 就是用来处理 key 键冲突的</p>
                            <p>内部也是调用了四个参数的 toMap() 方法</p>
                        </blockquote>
                        <p>例子</p>
<pre class="java"><code class="hljs"><span class="hljs-comment">// 如果 key 冲突，那么将冲突的 value 值拼接在一起</span>
Map&lt;String, String&gt; map3 = userList.parallelStream()
                .collect(Collectors.toMap(
                    e -&gt; e.getGender(), 
                    e -&gt; e.getName(), 
                    (o1, o2) -&gt; o1 + <span class="hljs-string">", "</span> + o2
                    )
                );
System.out.println(map3);</code></pre>
                        <p>你：我想自己 new 一个 Map 对象</p>
                        <p><strong>四个参数的 toMap</strong></p>
<pre class="java"><code class="hljs">Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; keyMapper,
                            Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; valueMapper,
                            BinaryOperator&lt;U&gt; mergeFunction,
                            Supplier&lt;M&gt; mapSupplier) </code></pre>
                        <blockquote>
                            <p>参数 <code>mapSupplier</code> 用来提供返回容器</p>
                        </blockquote>
                        <p>例子</p>
<pre class="java"><code class="hljs">LinkedHashMap&lt;String, String&gt; map4 = userList.parallelStream()
                .collect(Collectors.toMap(e -&gt; e.getGender(), e -&gt; e.getName(), (o1, o2) -&gt; o1 + <span class="hljs-string">", "</span> + o2, LinkedHashMap::<span class="hljs-keyword">new</span>));
System.out.println(map4);</code></pre>
                        <h4 id="reducing">reducing</h4>
                        <p><strong>单参数和两参数的 reducing()</strong></p>
<pre class="java"><code class="hljs">Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)
Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? <span class="hljs-keyword">super</span> T,? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</code></pre>
                        <p>以例子具体解释这两个方法</p>
<pre class="java"><code class="hljs">Optional&lt;String&gt; names1 = userList.stream()
                .map(User::getName)
                .collect(Collectors.reducing((e1, e2) -&gt; e1 + <span class="hljs-string">","</span> + e2));
System.out.println(names1.get());

<span class="hljs-comment">// 等同于</span>
String names2 = userList.stream()
            .collect(Collectors.reducing(
                        <span class="hljs-string">""</span>, (e) -&gt; e.getName(), (e1, e2) -&gt; e1 + <span class="hljs-string">","</span> + e2)
                    );
System.out.println(names2);</code></pre>
                        <p>输出结果：</p>
<pre><code class="hljs">小明,小青,小海,阿刁,小阳,小强,小帅,小云
,小明,小青,小海,阿刁,小阳,小强,小帅,小云</code></pre>
                        <blockquote>
                            <p>参数 <code>identity</code> 表示返回结果的初始值</p>
                        </blockquote>
                        <p><strong>三参数的 reducing()</strong></p>
<pre class="java"><code class="hljs">reducing(U identity, Function&lt;? <span class="hljs-keyword">super</span> T,? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</code></pre>
                        <p><code>identity</code> 是初始值，<code>mapper</code> 会对元素先进行一次处理，然后 <code>op</code> 对元素进行归约操作</p>
                        <blockquote>
                            <p>
                                注意： 返回类型要和参数 <code>identity</code> 的一致。<br />
                                你也许会纳闷，为什么有的返回一个 <code>Optional&lt;String&gt;</code> 类型数据，而有的就返回了 <code>String</code><br />
                                因为含有参数 <code>identity</code> 的 reduing 方法中返回值有初始值，也就是 identity，所以不会出现空的情况
                            </p>
                        </blockquote>
                        <p><strong>下面Collectors 提供的一些常用归约收集器</strong></p>
<pre class="java"><code class="hljs"><span class="hljs-comment">// minBy、maxBy</span>
Optional&lt;User&gt; minAgeUser = userList.stream()
                .collect(Collectors.minBy((o1, o2) -&gt; o1.getAge() - o2.getAge()));

<span class="hljs-comment">// counting</span>
Long count = userList.stream()
    .collect(Collectors.counting());

<span class="hljs-comment">// summingInt、summingLong、summingDouble、</span>
Integer sumAge = userList.stream()
    .collect(Collectors.summingInt(User::getAge));

<span class="hljs-comment">// averagingInt、averagingLong、averagingDouble</span>
<span class="hljs-comment">// 平均值内部是总值/数量，所以返回值是浮点数 dobule</span>
Double avgAge = userList.stream()
    .collect(Collectors.averagingInt(User::getAge));
</code></pre>
                        <p>
                            你也许觉得每次都要执行一遍 minBy、maxBy、counting、summingXxx、averagingXxx 这些太麻烦了，有没有一次执行就获取所有这些方法结果？<br />
                            有的。这就是 <code>summarizingXxx</code>
                        </p>
<pre class="java"><code class="hljs">Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? <span class="hljs-keyword">super</span> T&gt; mapper)
Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? <span class="hljs-keyword">super</span> T&gt; mapper)
Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? <span class="hljs-keyword">super</span> T&gt; mapper)</code></pre>
                        <p>这里不演示了，实际上你看一下 <code>XxxSummaryStatistics</code> 这些类就明白了，比如</p>
<pre class="java"><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntSummaryStatistics</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IntConsumer</span> </span>{
                        <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> count;
                        <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sum;
                        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;
                        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;
    ...
}</code></pre>
                        <h4 id="group-by">group by</h4>
                        <p>最最激动人心的时候到了，我们要使用分组了！！！</p>
<pre class="java"><code class="hljs">Map&lt;String, List&lt;User&gt;&gt; map = userList.stream()
                .collect(Collectors.groupingBy(User::getGender));</code></pre>
                        <p>SQL 中的 <code>group by</code> 结果集中只能包含分组字段和聚合函数计算结果，这段代码比它更加全面</p>
                        <p>我们使用如下语句输出结果</p>
<pre class="java"><code class="hljs">map.keySet().stream()
        .forEach((e) -&gt; {
            System.out.println(e + <span class="hljs-string">"="</span> + map.get(e));
        });</code></pre>
                        <p>显示结果：</p>
<pre><code class="hljs dockerfile">女=[<span class="hljs-keyword">User</span>{id=<span class="hljs-number">102</span>, name=<span class="hljs-string">'小青'</span>, age=<span class="hljs-number">12</span>, gender=<span class="hljs-string">'女'</span>, province=<span class="hljs-string">'宁夏回族自治区'</span>, city=<span class="hljs-string">'银川市'</span>}, <span class="hljs-keyword">User</span>{id=<span class="hljs-number">108</span>, name=<span class="hljs-string">'阿刁'</span>, age=<span class="hljs-number">18</span>, gender=<span class="hljs-string">'女'</span>, province=<span class="hljs-string">'西藏自治区'</span>, city=<span class="hljs-string">'拉萨市'</span>}, <span class="hljs-keyword">User</span>{id=<span class="hljs-number">104</span>, name=<span class="hljs-string">'小阳'</span>, age=<span class="hljs-number">9</span>, gender=<span class="hljs-string">'女'</span>, province=<span class="hljs-string">'新疆维吾尔自治区'</span>, city=<span class="hljs-string">'乌鲁木齐市'</span>}, <span class="hljs-keyword">User</span>{id=<span class="hljs-number">107</span>, name=<span class="hljs-string">'小云'</span>, age=<span class="hljs-number">15</span>, gender=<span class="hljs-string">'女'</span>, province=<span class="hljs-string">'河北省'</span>, city=<span class="hljs-string">'石家庄市'</span>}]
男=[<span class="hljs-keyword">User</span>{id=<span class="hljs-number">101</span>, name=<span class="hljs-string">'小明'</span>, age=<span class="hljs-number">10</span>, gender=<span class="hljs-string">'男'</span>, province=<span class="hljs-string">'青海省'</span>, city=<span class="hljs-string">'西宁市'</span>}, <span class="hljs-keyword">User</span>{id=<span class="hljs-number">103</span>, name=<span class="hljs-string">'小海'</span>, age=<span class="hljs-number">8</span>, gender=<span class="hljs-string">'男'</span>, province=<span class="hljs-string">'西藏自治区'</span>, city=<span class="hljs-string">'拉萨市'</span>}, <span class="hljs-keyword">User</span>{id=<span class="hljs-number">105</span>, name=<span class="hljs-string">'小强'</span>, age=<span class="hljs-number">14</span>, gender=<span class="hljs-string">'男'</span>, province=<span class="hljs-string">'陕西省'</span>, city=<span class="hljs-string">'西安市'</span>}, <span class="hljs-keyword">User</span>{id=<span class="hljs-number">106</span>, name=<span class="hljs-string">'小帅'</span>, age=<span class="hljs-number">15</span>, gender=<span class="hljs-string">'男'</span>, province=<span class="hljs-string">'河北省'</span>, city=<span class="hljs-string">'石家庄市'</span>}]
</code></pre>
                        <p>它真的分组了！！这是真正的分组</p>
                        <p>那怎么对分组中的元素进行操作呢，像 SQL 那样？？</p>
                        <p>完全不用担心，Collectors 提供了三个 groupBy 方法返回分组收集器</p>
<pre class="java"><code class="hljs">Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T,? extends K&gt; classifier)
    
Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T,? extends K&gt; classifier, 
                                      Collector&lt;? <span class="hljs-keyword">super</span> T,A,D&gt; downstream)
    
Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T,? extends K&gt; classifier, 
                              Supplier&lt;M&gt; mapFactory, 
                              Collector&lt;? <span class="hljs-keyword">super</span> T,A,D&gt; downstream)</code></pre>
                        <p>让我们放飞想象的翅膀，思考一下这几个参数分别有什么用。</p>
                        <p>downstream ？有 down 就表示有 up。那么谁是 upstream，很明显是 <code>userList.stream</code>，那么 downstream 就是分组集合的流喽。猜测 downstream 收集器是对分组中的元素进行归约操作的，就像是分组 SQL 语句字段中的聚合操作一样。</p>
<pre class="java"><code class="hljs"><span class="hljs-comment">// select gender, count(*) from user group by gender</span>
Map&lt;String, Long&gt; map2 = userList.stream()
                .collect(Collectors.groupingBy(User::getGender, Collectors.counting()));
System.out.println(map2);</code></pre>
                        <p>输出结果确实不出所料！这就是证明参数 <code>downstream</code> 确实是分组集合元素的收集器。</p>
                        <p><code>Supplier&lt;M&gt; mapFactory</code> 这函数式接口方法不会有参数传入，所以不会操作集合元素；它只是返回一个变量。同志们，注意观察三个方法返回值，前二者都指定了 Map 作为归约操作的返回类型，而第三个要我们自己定义，使用 <code>mapFactory</code> 提供返回的数据容器</p>
                        <p>两参数的 <code>groupingBy</code> 方法其实是调用了三参数的 <code>groupingBy</code> 方法（而单参数 <code>groupingBy</code> 调用了两参数的 <code>groupingBy</code>)</p>
<pre class="java"><code class="hljs">    Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier,
                                          Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream) {
                        <span class="hljs-keyword">return</span> groupingBy(classifier, HashMap::<span class="hljs-keyword">new</span>, downstream);
    }</code></pre>
                        <p><code>groupingBy</code> 经常使用 <code>Collectors.mapping()</code> 处理分组集合</p>
<pre class="java"><code class="hljs">Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; map4 = userList.stream()
    .collect(Collectors.groupingBy(
        User::getGender,
        Collectors.mapping(e -&gt; {
            Map&lt;String, Object&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
            m.put(<span class="hljs-string">"name"</span>, e.getName());
            m.put(<span class="hljs-string">"id"</span>, e.getId());
                        <span class="hljs-keyword">return</span> m;
        }, Collectors.toList())
    ));
System.out.println(map4);</code></pre>
                        <p>输出结果：</p>
<pre><code class="hljs clojure">{女=[{name=小青, id=102}, {name=阿刁, id=108}, {name=小阳, id=104}, {name=小云, id=107}], 男=[{name=小明, id=101}, {name=小海, id=103}, {name=小强, id=105}, {name=小帅, id=106}]}</code></pre>
                        <h4 id="partitionby">partitionBy</h4>
                        <p>实际上也是分组，只不过 partitionBy 是按照布尔值（真假）来分组</p>
<pre class="java"><code class="hljs">Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate) {
                        <span class="hljs-keyword">return</span> partitioningBy(predicate, toList());
}

Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate,
                                                    Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)</code></pre>
                        <p>例子：大于10岁为一组，小于等于10的为一组</p>
<pre class="java"><code class="hljs">Map&lt;Boolean, List&lt;User&gt;&gt; map1 = userList.stream()
                .collect(Collectors.partitioningBy(e -&gt; e.getAge() &gt; <span class="hljs-number">10</span>));</code></pre>
                        <p>例子：统计大于10岁的有多少人，小于等于10岁的有多少人</p>
<pre class="java"><code class="hljs">Map&lt;Boolean, Long&gt; map2 = userList.stream()
            .collect(Collectors.partitioningBy(e -&gt; e.getAge() &gt; <span class="hljs-number">10</span>, Collectors.counting()));</code></pre>
                        <p>第二个参数 <code>downstream</code> 用来处理分组集合</p>
                        <h3 id="结语">结语</h3>
                        <p>Java8 提供的 stream 几乎是穷尽了所有集合元素能有的操作，起码是穷尽了我脑海里对集合元素操作的所有想象</p>
                        <p>这篇文章也列举了 stream 绝大部分的功能，尽量写得通俗易懂，但读者理解起来可能还是有模糊的地方，这时建议大家参考 <a href="https://docs.oracle.com/javase/8/docs/api/">Java8 API 官方文档</a> ，多做几个 Demo 加深理解</p>
                        <p><strong>不要过度使用</strong></p>
                        <p>stream 是为了方便集合操作，简化代码而推出的，提升代码执行效率并不是它的目的。</p>
                        <p>虽然，并行流会对代码的执行效率有较大的提升（尤其是数据量非常大的时候），但也依赖于计算机的CPU配置。</p>
                        <p><strong>Stream 能实现的功能，for 循环都能实现，只是 Stream 代码一般比较简洁，可读性强。但在某些情况下，使用 for 循环要比 Stream 要简洁代码逻辑清晰</strong></p>
                        <p>举个例子：</p>
<pre class="java"><code class="hljs">    <span class="hljs-keyword">private</span> List&lt;Order&gt; orderList = Arrays.asList(
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">103</span>),
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">106</span>),
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">107</span>),
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">104</span>),
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">102</span>),
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">103</span>),
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">102</span>),
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">101</span>),
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">104</span>),
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">102</span>),
                        <span class="hljs-keyword">new</span> Order(<span class="hljs-number">105</span>)
    );
                        <span class="hljs-comment">// 现根据 userId 设置 Order 对象的 name 属性</span>
    
                        <span class="hljs-comment">// 使用 stream</span>
    List&lt;Order&gt; newOrderList = orderList.stream()
                .map(o -&gt; userList.stream()
                        .filter(u -&gt; u.getId() == o.getUserId())
                        .findFirst()
                        .map(u -&gt; {
                            o.setUserName(u.getName());
                        <span class="hljs-keyword">return</span> o;
                        })
                        .orElse(o))
                .collect(Collectors.toList());
    newOrderList.stream().forEach(System.out::println);

                        <span class="hljs-comment">// 使用 for 循环</span>
                        <span class="hljs-keyword">for</span> (Order o : orderList) {
                        <span class="hljs-keyword">for</span> (User u : userList) {
                        <span class="hljs-keyword">if</span> (o.getUserId() == u.getId()) {
                o.setUserName(u.getName());
                        <span class="hljs-keyword">break</span>;
            }
        }
    }
    orderList.stream().forEach(System.out::println);
</code></pre>
                        <p>在这个例子中，使用 for 循环要比 使用 stream 干净利落的多，代码逻辑清晰简明，可读性也比 stream 好。</p>
                    </div>
                </div>
                <div class="clr"></div>
            </div>
        </div>
        <div class="footer">
            <div class="footer_resize">
                <p class="lf">&copy; Copyright <a href="#">晓冬科技</a>. Collect from: <a href="http://www.hexiaodong.top/" title="" target="_blank">www.hexiaodong.top</a></p>
                <ul class="fmenu">
                    <li><a href="@Url.Action("Index")">首页</a></li>
                    <li><a href="@Url.Action("Blog")">博客</a></li>
                    <li><a href="@Url.Action("Contact")">联系我</a></li>
                </ul>
                <div class="clr"></div>
            </div>
        </div>
    </div>
</body>
</html>
